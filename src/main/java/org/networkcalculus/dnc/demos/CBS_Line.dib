#!markdown

This tutorials shows the code used for the examples in the *Quick Intro*.

The following three cells are setup: they compile the library, reference the necessary packages, define the functions we use to plot.
If I could abstract this out of view I would, alas you will have to scroll a bit.

#!csharp

#r "nuget: Unipi.Nancy"
// The following is the package we use to plot inside notebooks
#r "nuget: XPlot.Plotly.Interactive"

#!csharp

// Preamble code, see README.md for a quick reference on plot() 

using XPlot.Plotly;
using Unipi.Nancy.Numerics;
using Unipi.Nancy.MinPlusAlgebra;
using Unipi.Nancy.NetworkCalculus;

// the plot method, and its overloads, uses XPlot to plot the given curves
// there is no particular reason in the choice of XPlot, only that it works well in this context - it can be replaced with other libraries in other context
void plot(IEnumerable<Curve> curves, IEnumerable<string> names, Rational? upTo = null)
{
    //Console.WriteLine("plot(IEnumerable<(Curve curve, string name)> namedCurves, Rational? upTo = null)");
    Rational t;
    if(upTo is not null)
        t = (Rational) upTo;
    else
        t = curves.Max(c => c.SecondPseudoPeriodEnd);
    t = t == 0 ? 10 : t;
    //Console.WriteLine(t);

    var cuts = curves
        .Select(c => c.Cut(0, t, isEndInclusive: true))
        .ToList();
    
    plot(cuts, names);
}

void plot(Curve curve, string name, Rational? upTo = null)
{
    //Console.WriteLine("plot(Curve curve, string name, Rational? upTo = null)");
    plot(new []{curve}, new []{name}, upTo);
}

void plot(IEnumerable<Curve> curves, Rational? upTo = null)
{
    //Console.WriteLine("plot(IEnumerable<Curve> curves, Rational? upTo = null)");
    var names = curves.Select((_, i) => $"{(char)('a' + i)}");
    plot(curves, names, upTo);
}

void plot(Curve curve, Rational? upTo = null)
{
    //Console.WriteLine("plot(Curve curve, Rational? upTo = null)");
    plot(new []{curve}, new []{"a"}, upTo);
}

void plot(params Curve[] curves)
{
    //Console.WriteLine("plot(params Curve[] curves)");
    plot(curves, null);
}

void plot(IEnumerable<Sequence> sequences, IEnumerable<string> names)
{
    //Console.WriteLine("plot(IEnumerable<(Sequence sequence, string name)> namedSequences)");
    var colors = new List<string> {
        "#636EFA",
        "#EF553B",
        "#00CC96",
        "#AB63FA",
        "#FFA15A",
        "#19D3F3",
        "#FF6692",
        "#B6E880",
        "#FF97FF",
        "#FECB52"
    };

    var traces = Enumerable.Zip(sequences, names) 
        .SelectMany((ns, i) => getTrace(ns.First, ns.Second, i));

    var chart = Chart.Plot(traces);
    
    chart.WithLayout(
        new Layout.Layout {
            xaxis = new Xaxis { zeroline = true, showgrid = true, title = "time" },
            yaxis = new Yaxis { zeroline = true, showgrid = true, title = "data" },
            showlegend = true,
            hovermode = "closest"
        }
    );

    display(chart);
    
    IEnumerable<Scattergl> getTrace(Sequence sequence, string name, int index)
    {
        var color = colors[index % colors.Count];

        if(sequence.IsContinuous)
        {
            var points = sequence.Elements
                .Where(e => e is Point)
                .Select(e => (Point) e)
                .Select(p => (x: (decimal) p.Time, y: (decimal) p.Value))
                .ToList();

            if(sequence.IsRightOpen)
            {
                var tail = sequence.Elements.Last() as Segment;
                points.Add((x: (decimal) tail.EndTime, y: (decimal) tail.LeftLimitAtEndTime));
            }

            var trace = new Scattergl {
                x = points.Select(p => p.x).ToArray(),
                y = points.Select(p => p.y).ToArray(),
                name = name,
                fillcolor = color,
                mode = "lines+markers",
                line = new Line {
                    color = color
                },
                marker = new Marker {
                    symbol = "circle",
                    color = color
                }
            };
            yield return trace;
        }
        else
        {
            var segments = new List<((decimal x, decimal y) a, (decimal x, decimal y) b)>();
            var points = new List<(decimal x, decimal y)>();
            var discontinuities = new List<(decimal x, decimal y)>();
            
            var breakpoints = sequence.EnumerateBreakpoints();
            foreach(var (left, center, right) in breakpoints)
            {
                points.Add((x: (decimal) center.Time, y: (decimal) center.Value));
                if(left is not null && left.LeftLimitAtEndTime != center.Value)
                {
                    discontinuities.Add((x: (decimal) center.Time, y: (decimal) left.LeftLimitAtEndTime));
                }
                if(right is not null)
                {
                    segments.Add((
                        a: (x: (decimal) right.StartTime, y: (decimal) right.RightLimitAtStartTime),
                        b: (x: (decimal) right.EndTime, y: (decimal) right.LeftLimitAtEndTime)
                    ));
                    if(right.RightLimitAtStartTime != center.Value)
                    {
                        discontinuities.Add((x: (decimal) center.Time, y: (decimal) right.RightLimitAtStartTime));
                    }
                }
            }
            if(sequence.IsRightOpen)
            {
                var tail = sequence.Elements.Last() as Segment;
                segments.Add((
                    a: (x: (decimal) tail.StartTime, y: (decimal) tail.RightLimitAtStartTime),
                    b: (x: (decimal) tail.EndTime, y: (decimal) tail.LeftLimitAtEndTime)
                ));
            }

            var segmentsLegend = segments.Any();

            bool isFirst = true;
            foreach(var (a, b) in segments)
            {
                var trace = new Scattergl {
                    x = new []{ a.x, b.x },
                    y = new []{ a.y, b.y },
                    name = name,
                    legendgroup = name,
                    fillcolor = color,
                    mode = "lines",
                    line = new Line {
                        color = color
                    },
                    showlegend = segmentsLegend && isFirst
                };
                yield return trace;
                isFirst = false; 
            }
            
            var pointsTrace = new Scattergl {
                x = points.Select(p => p.x).ToArray(),
                y = points.Select(p => p.y).ToArray(),
                name = name,
                legendgroup = name,
                fillcolor = color,
                mode = "markers",
                line = new Line {
                    color = color
                },
                marker = new Marker {
                    symbol = "circle",
                    color = color
                },
                showlegend = !segmentsLegend
            };
            yield return pointsTrace;

            var discontinuitiesTrace = new Scattergl {
                x = discontinuities.Select(p => p.x).ToArray(),
                y = discontinuities.Select(p => p.y).ToArray(),
                name = name,
                legendgroup = name,
                fillcolor = color,
                mode = "markers",
                line = new Line {
                    color = color
                },
                marker = new Marker {
                    symbol = "circle-open",
                    color = color,
                    line = new Line {
                        color = color
                    }
                },
                showlegend = false,
            };
            yield return discontinuitiesTrace;
        }
    }
}

void plot(Sequence sequence, string name)
{
    //Console.WriteLine("plot(Sequence sequence, string name)");
    plot(new []{sequence}, new []{name});
}

void plot(IEnumerable<Sequence> sequences)
{
    //Console.WriteLine("plot(IEnumerable<Sequence> sequences)");
    var names = sequences.Select((_, i) => $"{(char)('a' + i)}");
    plot(sequences, names);
}

void plot(Sequence sequence)
{
    //Console.WriteLine("plot(Sequence sequence)");
    plot(new []{sequence}, new []{"a"});
}

#!markdown

# CBS Network
<img src="./CBS_Line.png" alt="S_1SC_1F_1AC_Network" height="300" />

## Flow 1 and Flow 4 @ Server s1

#!csharp

// Aggregated ArrivalCurve F1 and F4 at S4
var ac_f1 = new SigmaRhoArrivalCurve(sigma: 509.37856m, rho: 512000.0m);
var ac_f4 = new SigmaRhoArrivalCurve(sigma: 509.37856m, rho: 512000.0m);
var aggr_ac = Curve.Addition(ac_f1, ac_f4);
plot(new Curve[]{ac_f1, ac_f4, aggr_ac}, new []{"ac_f1", "ac_f4", "aggr_ac"}, 0.0002m);

var sc = new RateLatencyServiceCurve(rate: 1024000.0m, latency: 0.00012m);

var deconv = Curve.Deconvolution(aggr_ac, sc);
plot(new Curve[]{aggr_ac, sc, deconv}, new []{"aggr_ac", "sc", "deconv"}, 0.0002m);

#!csharp

var cbs_shaper = new SigmaRhoArrivalCurve(sigma: 629.6312m, rho: 1024000.0m);
var ac_cbs_shaped = Curve.Minimum(deconv, cbs_shaper);
plot(new Curve[]{cbs_shaper, ac_cbs_shaped, deconv}, new []{"CBS shaper", "CBS shaped AC", "deconv"}, 0.00015m);

#!csharp

var link_shaper = new SigmaRhoArrivalCurve(sigma: 512.0m, rho: 100000000.0m);
var ac_link_shaped = Curve.Minimum(link_shaper, ac_cbs_shaped);
plot(new Curve[]{link_shaper, ac_link_shaped, ac_cbs_shaped}, new []{"Link shaper", "Link shaped AC", "CBS shaped AC"}, 0.0001m);

#!csharp

var delay_s1 = Curve.HorizontalDeviation(ac_link_shaped, sc);
Console.WriteLine("Delay @s1: " + delay_s1);

#!markdown

## Flow 1 and Flow 4 @ Server s2

#!csharp

// Aggregated ArrivalCurve F1 and F4 at S2
var aggr_ac_s2 = ac_link_shaped;
var sc_s2 = new RateLatencyServiceCurve(rate: 1024000.0m, latency: 0.00012m);

var deconv_s2 = Curve.Deconvolution(aggr_ac_s2, sc_s2);
plot(new Curve[]{aggr_ac, sc, deconv}, new []{"aggr_ac_s2", "sc_s2", "deconv_s2"}, 0.001m);

#!csharp

var cbs_shaper_s2 = new SigmaRhoArrivalCurve(sigma: 629.6312m, rho: 1024000.0m);
var ac_cbs_shaped_s2 = Curve.Minimum(deconv_s2, cbs_shaper_s2);
plot(new Curve[]{cbs_shaper_s2, ac_cbs_shaped_s2, deconv_s2}, new []{"CBS shaper", "CBS shaped AC", "deconv"}, 0.0002m);

#!csharp

var link_shaper = new SigmaRhoArrivalCurve(sigma: 512.0m, rho: 100000000.0m);
var ac_link_shaped_s2 = Curve.Minimum(link_shaper, ac_cbs_shaped_s2);
plot(new Curve[]{link_shaper, ac_link_shaped_s2, ac_cbs_shaped_s2}, new []{"Link shaper", "Link shaped AC", "CBS shaped AC"}, 0.0001m);

#!csharp

var delay_s2 = Curve.HorizontalDeviation(ac_link_shaped_s2, sc_s2);
Console.WriteLine("Delay @s2: " + delay_s2);

#!markdown

## Flow 1 and Flow 4 @ Server s3

#!csharp

// Aggregated ArrivalCurve F1 and F4 at S3
var aggr_ac_s3 = ac_link_shaped_s2;
var sc_s3 = new RateLatencyServiceCurve(rate: 1024000.0m, latency: 0.00012m);

var deconv_s3 = Curve.Deconvolution(aggr_ac_s3, sc_s3);
plot(new Curve[]{aggr_ac, sc, deconv}, new []{"aggr_ac_s3", "sc_s3", "deconv_s3"}, 0.001m);

#!csharp

var cbs_shaper_s3 = new SigmaRhoArrivalCurve(sigma: 629.6312m, rho: 1024000.0m);
var ac_cbs_shaped_s3 = Curve.Minimum(deconv_s3, cbs_shaper_s3);
plot(new Curve[]{cbs_shaper_s3, ac_cbs_shaped_s3, deconv_s3}, new []{"CBS shaper", "CBS shaped AC", "deconv"}, 0.0002m);

#!csharp

var link_shaper = new SigmaRhoArrivalCurve(sigma: 512.0m, rho: 100000000.0m);
var ac_link_shaped_s3 = Curve.Minimum(link_shaper, ac_cbs_shaped_s3);
plot(new Curve[]{link_shaper, ac_link_shaped_s3, ac_cbs_shaped_s3}, new []{"Link shaper", "Link shaped AC", "CBS shaped AC"}, 0.0001m);

#!csharp

var delay_s3 = Curve.HorizontalDeviation(ac_link_shaped_s3, sc_s3);
Console.WriteLine("Delay @s3: " + delay_s3);

#!markdown

## Flow 1 and Flow 4 @ Server s4

#!csharp

// Aggregated ArrivalCurve F1 and F4 at S4
var aggr_ac_s4 = ac_link_shaped_s3;
var sc_s4 = new RateLatencyServiceCurve(rate: 1024000.0m, latency: 0.00012m);

var deconv_s4 = Curve.Deconvolution(aggr_ac_s4, sc_s4);
plot(new Curve[]{aggr_ac, sc, deconv}, new []{"aggr_ac_s4", "sc_s4", "deconv_s4"}, 0.001m);

#!csharp

var cbs_shaper_s4 = new SigmaRhoArrivalCurve(sigma: 629.6312m, rho: 1024000.0m);
var ac_cbs_shaped_s4 = Curve.Minimum(deconv_s4, cbs_shaper_s4);
plot(new Curve[]{cbs_shaper_s4, ac_cbs_shaped_s4, deconv_s4}, new []{"CBS shaper", "CBS shaped AC", "deconv"}, 0.0005m);

#!csharp

var link_shaper = new SigmaRhoArrivalCurve(sigma: 512.0m, rho: 100000000.0m);
var ac_link_shaped_s4 = Curve.Minimum(link_shaper, ac_cbs_shaped_s4);
plot(new Curve[]{link_shaper, ac_link_shaped_s4, ac_cbs_shaped_s4}, new []{"Link shaper", "Link shaped AC", "CBS shaped AC"}, 0.0001m);

#!csharp

var delay_s4 = Curve.HorizontalDeviation(ac_link_shaped_s4, sc_s4);
Console.WriteLine("Delay @s4: " + delay_s4);

var delay = delay_s1 + delay_s2 + delay_s3 + delay_s4;
Console.WriteLine("Total delay: " + delay);
